1. Модель (Model)
Body.java, Engine.java, Accessory.java (детали)
Поля:

id: int - уникальный идентификатор

Методы:

getId(): int

Car.java (машина)
Поля:

id: int

body: Body

engine: Engine

accessory: Accessory

Методы:

Геттеры для всех полей

Storage<T>.java (абстрактный склад)
Поля:

capacity: int - вместимость

items: Queue<T> - очередь деталей

lock: Object - для синхронизации

Методы:

add(item: T): void

take(): T

getSize(): int

getCapacity(): int

BodyStorage.java, EngineStorage.java, AccessoryStorage.java, CarStorage.java
Наследуют Storage<T> без дополнительных полей/методов

2. Потоки (Threads)
StoppableThread.java (абстрактный поток)
Поля:

running: boolean - флаг работы

Методы:

stopThread(): void

Supplier<T>.java (абстрактный поставщик)
Поля:

storage: Storage<T>

id: int

delay: int

suppliedCount: int

Методы:

run(): void

createItem(): T (абстрактный)

setDelay(delay: int): void

BodySupplier.java, EngineSupplier.java, AccessorySupplier.java
Реализуют createItem() для своих деталей

Worker.java (рабочий)
Поля:

id: int

Хранилища для всех типов деталей

onCarProduced: Runnable - callback

Методы:

run(): void - берет детали и собирает машину

Dealer.java (дилер)
Поля:

id: int

carStorage: CarStorage

delay: int

logger: Logger

Методы:

run(): void - забирает и продает машины

ThreadPool.java (пул потоков)
Поля:

taskQueue: BlockingQueue<Runnable>

workerThreads: Thread[]

workerIdCounter: int

Методы:

addTask(task: Runnable): void

getNextWorkerId(): int

shutdown(): void

3. Контроллеры (Controller)
CarStorageController.java
Поля:

Все хранилища

threadPool: ThreadPool

refillThreshold: double

Методы:

onCarSold(): void - проверяет и пополняет склад

FactoryController.java
Поля:

Все хранилища

Списки поставщиков и дилеров

threadPool: ThreadPool

isRunning: boolean

Методы:

startProduction(): void

stopProduction(): void

Геттеры для хранилищ

4. Представление (View)
FactoryView.java
Поля:

Метки для отображения (bodyStorageLabel, producedCarsLabel и т.д.)

Кнопки (startButton, stopButton)

animationPane: Pane для анимаций

Коллекции для визуальных компонентов

Методы:

update(): void - обновляет все метки

animatePartMovement(type: PartType): void

createProductionScheme(): Group - создает схему фабрики

Методы для создания UI-элементов

5. Вспомогательные классы
Config.java
Поля:

Все параметры из start.properties

Методы:

Загрузка конфигурации

Геттеры для всех параметров

Logger.java
Поля:

writer: PrintWriter

isEnabled: boolean

Методы:

logSale(dealerId: int, car: Car): void

close(): void

Main.java
Методы:

start(stage: Stage): void - инициализация приложения

Полная схема взаимодействия:
Запуск:

Main → создает Config, FactoryController, FactoryView

FactoryController инициализирует все компоненты

Работа:

Поставщики наполняют склады

Контроллер создает задачи для рабочих

Рабочие собирают машины

Дилеры забирают машины

Отображение:

FactoryView получает обновления через Observer

Анимирует перемещение деталей


Задание:
Напишите приложение, эмулирующее работу фабрики по сборке автомашин. Машина
состоит из 3-х частей: кузов, двигатель и аксессуары. Машину надо собрать и отвезти на
склад, откуда она поступает дилерам. Процесс работы фабрики:
1) в программу поступает файл start.properties , где указаны параметры для работы программы
StorageBodySize=100 - максимальное количтво мето на складе для этой детали
StorageMotorSize=100
StorageAccessorySize=100
StorageAutoSize=100
AccessorySuppliers=5 - количство поставщиков
BodySuppliers = 5
EngineSuppliers = 5
Workers=10 -  количество рабочих
Dealers=20 -  количство дилеров
LogSale=true -  нужно ли при покупке машины дилером добавлять запись о покупке в файл shops.txt, куда после покупки поместиться просто строка:
&lt;Time&gt;: Dealer &lt;Number&gt;: Auto &lt;ID&gt; (Body: &lt;ID&gt;, Motor: &lt;ID&gt;, Accessory: &lt;ID&gt;)

2) программа запускает визуал, который запускает контроллер( верное ли это решение?)

как работает контрллер: FactoryController - содержит в себе логику работы фабрики машин. Тоесть должен запускать потоки поставщиков, рабочих и дилеров, а так же должен контролировать склад машин ( для этого специальный класс CarStorageController( активируется , после покупки машины, если на складе машин , машин меньше 80% , то просит рабочих сделать еще машин.)

3)Визуальная часть: с помощью javafx нужно сделать окно в котором видно( то есть отображает количество ) как прибавляются детали( видно что поставщики работают), видно как появляются машины( работают рабочие) и машины убавляются при покупке диллером
Также должен быть ползунок, который меняет скорость работы потоков( поставщиков, рабочих, дилеров). В моей программе я уже придумала как это примерно будет выглядить, вот часть кода

   componentViews.put(BodySupplier.class, createComponentView("/images/supplies.png", 50, 100, "Body Supplier"));
        componentViews.put(EngineSupplier.class, createComponentView("/images/supplies.png", 50, 200, "Engine Supplier"));
        componentViews.put(AccessorySupplier.class, createComponentView("/images/supplies.png", 50, 300, "Accessory Supplier"));

        componentViews.put(BodyStorage.class, createComponentView("/images/storage.png", 200, 100, "Body Storage"));
        componentViews.put(EngineStorage.class, createComponentView("/images/storage.png", 200, 200, "Engine Storage"));
        componentViews.put(AccessoryStorage.class, createComponentView("/images/storage.png", 200, 300, "Accessory Storage"));

        componentViews.put(Worker.class, createComponentView("/images/worker.png", 400, 200, "Workers"));
        componentViews.put(CarStorage.class, createComponentView("/images/storage.png", 550, 200, "Car Storage"));
        componentViews.put(Dealer.class, createComponentView("/images/dealer.png", 700, 200, "Dealers"));

        // Соединительные линии
        createConnectionLines(scheme);

        // Добавляем все компоненты в схему
        scheme.getChildren().addAll(componentViews.values());
        return scheme;
    }

    private void createConnectionLines(Group scheme) {
        // Горизонтальные линии от поставщиков к складам
        scheme.getChildren().addAll(
                createConnectionLine(120, 125, 175, 125), // Body
                createConnectionLine(120, 225, 175, 225), // Engine
                createConnectionLine(120, 325, 175, 325)  // Accessory
        );

        // Линии от складов к рабочим
        scheme.getChildren().addAll(
                createConnectionLine(270, 125, 400, 210), // Body to Worker
                createConnectionLine(270, 225, 400, 210), // Engine to Worker
                createConnectionLine(270, 325, 400, 210)  // Accessory to Worker
        );

        // Линии от рабочих к складу машин и дилерам
        scheme.getChildren().addAll(
                createConnectionLine(450, 200, 525, 200), // Worker to CarStorage
                createConnectionLine(600, 200, 675, 200)  // CarStorage to Dealers
        );
    }
3. Требования к программе
1. Все склады имеют определенный размер, который нельзя превышать. Размеры
складов, количество сборщиков, поставщиков и дилеров задаются в
конфигурационном файле. Приложение предоставляет графический интерфейс
(библиотека Swing), где можно смотреть основные параметры работы фабрики и
контролировать процесс.

Факультет Информационных Технологий, 2-й курс, IV семестр
Курс: Объектно-ориентированное программирование

2
2. Каждый сборщик, поставщик и дилер должен работать в отдельном потоке. Для
синхронизации и ожидания событий необходимо использовать мониторы
синхронизации (notify(), notifyAll(), wait()). Наличие процедуры ожидания в виде
цикла автоматически ведет к непринятию задания. Каждая деталь - это отдельный
объект. Хранить просто количество изделий/деталей нельзя - необходимо хранить
непосредственно объекты. Каждый объект должен иметь уникальный
идентификатор для отслеживания.
3. Потоки, которые представляют поставщиков деталей, поставляют одну деталь раз в
N миллисекунд. Если какой-то склад деталей полон, то поставщик ожидает
освобождения места для деталей (используя методы wait(), notify()). Скорость
работы поставщиков определяется 3-мя ползунками (для каждого типа деталей).
Должно отображаться кол-во деталей на каждом из складов в текущий момент и
кол-во деталей, произведенных поставщиками (для поставщиков аксессуаров
можно общий показывать).
4. Потоки, которые представляют дилеров, запрашивают со склада готовой
продукции 1 машину в M миллисекунд. Скорость запрашивания машин можно
регулировать ползунком в интерфейсе окна. Интерфейс также должен показывать
кол-во произведенных машин (вообще) и кол-во машин на складе в данный
момент. При отправке машины дилеру информация о покупке должна писаться в
лог работы фабрики (в файл) в виде строки:
&lt;Time&gt;: Dealer &lt;Number&gt;: Auto &lt;ID&gt; (Body: &lt;ID&gt;, Motor: &lt;ID&gt;, Accessory: &lt;ID&gt;)
Включение/отключение лога контролируется с помощью специального параметра в
конфигурационном файле.
5. Поток контроллера склада готовой продукции просыпается при любом отправке
машины со склада продукции. Он анализирует состояние склада и передает запрос
на изготовление новых машин (в случае необходимости) на фабрику.
6. На фабрике работает несколько потоков (сборщиков) в рамках ThreadPool.
Задачами для ThreadPool являются запросы на создание новых машин (от
контроллера склада готовых изделий). При выполнении такой задачи сборщик
должен взять по одной детали, необходимой для сборки машины, с
соответствующих складов. Если на складе нет нужной детали, то поток ждет
поставки. Собирая новую машину, рабочий создает новый объект и с помощью
всех необходимых объектов, представляющих детали. После этого объект
отправляется на склад готовой продукции. Если склад полон, то рабочий ждет
освобождения места для новой машины. Интерфейс должен отображать, сколько
всего было сделано машин и сколько задач еще ждут исполнителя (в очереди задач
ThreadPool).
7. Конфигурационный файл должен предоставлять настройки для задания
вместимости всех складов и количестве всех типов потоков. Примерный список
параметров в конфигурационном файле (просьба использовать свои имена):
StorageBodySize=100
StorageMotorSize=100
StorageAccessorySize=100
StorageAutoSize=100
AccessorySuppliers=5
Workers=10
Dealers=20
LogSale=true
8. Информацию о потоках и концепции ThreadPool можно найти на страничках:
http://ccfit.nsu.ru/~rylov/java_lections/index.html (Лекции №8, №9).
 http://ccfit.nsu.ru/~deviv/ (ООП- &gt;Java -&gt;Документация-&gt; Thinking in Java).